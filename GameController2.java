import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;

/**
   This class is the CONTROLLER in the MVC representation
   of the soory game. It contains references to the MODEL
   and VIEW and is owned by the top level container. It's
   main function is to manage events generated by the user
   interacting with the VIEW and to update the MODEL 
   appropriately. This functionality is achieved largely
   in its private Listener classes.
   
   This class also calls Ruleset methods to simulate AI
   moves. It essentially attempts to programmatically
   emulate AI turn "events" analogous to the human 
   generated UI events.
   
   Side Note: The 2 is comes from a point in development
   when we where experimenting with 2 different program
   structures. This one won out.
*/

public class GameController2{
//*************************************************************************
// INSTANCE VARIABLES
//*************************************************************************
   /** The MODEL of the game */
   private Game game;
   /** The VIEW of the game's board itself */
   private BoardPanel boardPanel;
   /** The VIEW of the current turn's meta data */
   private GamePanel gamePanel;
   
   /** Flag indicating an AI turn in progress */
   private boolean aiThinking;
   /** Holds the current AI move action (when applicable) */
   private Move aiMove;
   
   
   /** Internal state parameter indicating if the game is
       over or not.*/
   boolean gameOver;
//*************************************************************************
// CONSTRUCTORS
//*************************************************************************   
   /**
      Since the board and rules setup are embedded in the game model
      (analogous to a physical board, pieces, and rulebook) a list of
      players is enough for the controller to create a valid model
      and then to create of view of that model.
   */
   public GameController2(ArrayList<Player> p){

      SimpleBoard b = new SimpleBoard(); // Board. The board never changes.
    
      // a game consists of the board (with pieces), the rules, and the players                  
      game = new Game(b , new SimpleRules(), p);

      // VIEW component 1
      boardPanel = new BoardPanel(game);
      boardPanel.addMouseListener(new BoardListener());
      
      // VIEW component 2      
      gamePanel = new GamePanel(game);
      gamePanel.getOkButton().addActionListener(new ButtonListener());
      gamePanel.getBumpButton().addActionListener(new ButtonListener());
      gamePanel.getSwapButton().addActionListener(new ButtonListener());
      // note that both views are dependent on the same game Model
      
      startTurn(); // once the board is set up we can begin      
   }
//*************************************************************************
// METHODS
//*************************************************************************   
   /**
      startTurn controls the "rising edge" of a game turn.
      It checks to see if someone won (ending the game if so)
      and checks to see if the current player is human or AI.
      If AI it calls methods to emulate AI actions otherwise
      if waits for actual human action (to be detected by the
      listeners)
   */   
   private void startTurn(){
      aiThinking = false;  // reset AI turn flag
      Color winColor = game.winner();  // Did someone win? If so STOP
      if (winColor != null){
         gameOver = true;
         gamePanel.gameWon();
         return;              // BREAK STATEMENT 
      }
      gamePanel.update();  // if the game isn't over update the view
      
      // set up first move...
      if (game.getMoveablePawns().size() == 0){ // ...unless player can't do anything
            gamePanel.okToProceed("Player cannot move and must forfeit their turn."); // FORFEIT TURN 
                                                                                       // message & button
      }
      else{ // PLAYER CAN MOVE...
         if (!game.isCurrentPlayerHuman()){ //... are they AI or human?
            aiThinking = true;
            aiTurn();   // AI Turns are driven by methods
         }
         else{
            aiThinking = false; // Human player turns are driven by events
         }
      }
   }// end of startturn
//-------------------------------------------------------------------------   
   /**
      aiTurn procedurally emulates actions comparable to
      those of a human player during their turn. Essentially
      the AI considers the list of possible moves based on their
      personality and selects a move from that list. The chosen
      move is then processed just like a regular human move.
   */
   private void aiTurn(){
      ArrayList<Pawn> moveablePawns = game.getMoveablePawns(); // all posible spaces
      int i = 0;
      Move myMove = null;
      // take first legitimate in character move;
      while ((myMove == null) && (i < moveablePawns.size())){
         myMove = AIRules.play(game.getCurrentPlayer(),
                               game.getAllTargets(moveablePawns.get(i))); // filter list by in character moves
        
         i++; 
      } 
      if (i >= moveablePawns.size())
         i--;
                                 
      // moveable pawn randomly selected from candiate list
      if (myMove == null){ // make sure we SOMETHING to choose, even if out of character
         myMove = AIRules.playCrazy(game.getCurrentPlayer(), game.getAllTargets(moveablePawns.get(0)));
         boardPanel.selectPawn(moveablePawns.get(0));
      }
      else{
         boardPanel.selectPawn(moveablePawns.get(i));
      }
      aiMove = myMove;// assign selected move, will be executed after player button press
      
      gamePanel.okToProceed(game.getCurrentPlayer().getName() + " has chosen their move."); // acknowledge message & button
   
   }//Êend of aiturn
   
//*************************************************************************
// SIMPLE GETTERS
//*************************************************************************  
   /** @return Game MODEL */
   public Game getGame(){
      return game;
   }
//-------------------------------------------------------------------------
   /** @return Board display component of VIEW */
   public BoardPanel getBoardPanel(){
      return boardPanel;
   }
//-------------------------------------------------------------------------
   /** @return UI display component of VIEW */
   public GamePanel getGamePanel(){
      return gamePanel;
   } 
//-------------------------------------------------------------------------
   /** 
      @return toString() result of board owned by game
      Intended as a convenience function for test
   */
   public String toString(){
      return game.getBoard().toString();
   }
//*************************************************************************
// LISTENERS
//************************************************************************* 
    /**
      Detects clicks on the game board. This represents the user's main
      interaction with the game. This interaction requires the controller
      to keep track of/know about the following things:
         - If the game is over: no interaction allowed
         - If it's the AI turn: The human cannot create events
           while the AI is thinking or moving
         - What Space was clicked on
         - If a pawn is selected or not: by context clicking
           with a Pawn selected implies an attempted move
         - If a space is selected: object is in the middle
           of a special ambiguous move
    */
    private class BoardListener implements MouseListener{
       // We're not interested in most mouse events but we need to satisfy the interface
       public void mouseClicked(MouseEvent e) {}
       public void mouseReleased(MouseEvent e) {}
       public void mouseEntered(MouseEvent e) {}
       public void mouseExited(MouseEvent e) {}
       // Here's the one we want
       public void mousePressed(MouseEvent e) {
            
            if ((gameOver) || (aiThinking)) return; // GUARD STATEMENT - ignore clicks after victory
                                                     // or if the AI's turn
            
           // Get grid coords of mouse click and clicked on space if applicable
           int clickedX = boardPanel.getGridX(e.getX());
           int clickedY = boardPanel.getGridY(e.getY());
           Space clickedSpace = game.getBoard().getSpace(clickedX, clickedY);
           Pawn clickedPawn;
           if ((clickedSpace != null) && 
               !boardPanel.isSpaceSelected() && // left mouse ignored with waiting for a button press
               (SwingUtilities.isLeftMouseButton(e))){ // LEFT CLICK SELECTS (if valid space)

              // TWO UI STATES: Either pawn selected or not
              // if no pawn is selected we could select a pawn
              if (!boardPanel.isPawnSelected()){ 
                  clickedPawn = clickedSpace.getPawn();
                  // Can only select a pawn if it's that player's turn and if it can be moved
                  if ((clickedPawn != null) && 
                      (clickedPawn.getColor().toString().equals(game.getCurrentPlayer().getColor().toString())) &&
                      (game.getAllTargets(clickedPawn).size() > 0)){
                     boardPanel.selectPawn(clickedPawn);  // Actual pawn selection op
                  }
              }
              // else if pawn selected we might be able to move it
              else{ 
                  // Find all moves which will take the selected pawn to the clicked space
                  ArrayList<Move> germaneMoves = 
                                       Move.subsetTargeting(game.getAllTargets(boardPanel.getSelectedPawn()),
                                                            clickedSpace);
                  
                  // Only proceed if we CAN move to the selected space
                  if (germaneMoves.size() > 0){
                     // If there are no swap/bump ambiguities we can simply pick any
                     // move from the subset - defaults to first one
                     // It is important to note that a seven move may NEVER result in
                     // this type of ambiguity - a 7 always bumps
                     if (!game.getRules().containsAmbiguousMove(germaneMoves, clickedSpace)){
                           game.getRules().move(boardPanel.getSelectedPawn(),
                                                clickedSpace,
                                                germaneMoves.get(0).getMove()); // actual move op
                         boardPanel.deselectPawn(); // done with pawn
                         
                         if (germaneMoves.get(0).getChain() != null){ // A chained multimove doesn't end the player's turn
                           game.setMoves(new int[] {germaneMoves.get(0).getChain().intValue()}); // can still try to move with residue
                         }
                         else{
                           game.nextTurn();  // but most moves simply end the player's turn
                           startTurn();
                         }
                         
                   
   
                     }
                     // If there is an ambiguous move then we need to put boardpanel
                     // into it's special bump or swap query state to handle 
                     // (uses button listeners)
                     else{
                        boardPanel.selectSpace(clickedSpace);
                        gamePanel.ambiguityQuery();
                     }
                  
                  
                  }// end of CAN move to the selected space
                  
                 
                  
              }// end if pawn selected we might be able to move it

           }// END IF LEFT CLICK
           
           // IF RIGHT CLICK
           else if (SwingUtilities.isRightMouseButton(e) && !aiThinking){ 
               // right click always deselects one "level" of stuff in boardpanel
               if (boardPanel.isSpaceSelected()){
                     boardPanel.deselectSpace();
                     gamePanel.update();
                  }
               else
                  boardPanel.deselectPawn(); 
           }// END IF RIGHT CLICK
           
           // Always redraw the GUI after a mouse event - something may have changed
           boardPanel.revalidate();
       }
   
    }// end of class boardListener
//-------------------------------------------------------------------------
   /**
     Handles all possible GamePanel button events except the Game Won
     button click (handled by SorryGame).
      OK - Appears when the Human user must acknowledge an event 
           they have no other input in:
            1. an AI move or 
            2. a turn they must pass
      SWAP or BUMP - permits a human player to resolve an ambiguity
         between moving into an enemy pawn 11 spaces away (bumping them)
         or swapping with an enemy pawn.

      Note that the these listeners will only function properly if the
      GamePanel is displaying the correct buttons for the current situation.
   */
   private class ButtonListener implements ActionListener{
   
      public void actionPerformed(ActionEvent e){
         String action = e.getActionCommand();
         //System.out.println(action);
         
         // ACKNOWLEDGE AND PROCEED
         if (action.equals(GamePanel.OK_TEXT)){
            if (aiThinking){ // AI TURN OCCURRING
               game.getRules().move(boardPanel.getSelectedPawn(), 
                                  aiMove.getTarget(), 
                                  aiMove.getMove());
               boardPanel.deselectPawn();
               if (aiMove.getChain() != null){ // A chained multimove doesn't end the ai player's turn
                           game.setMoves(new int[] {aiMove.getChain().intValue()});
                           aiTurn();
               }
               else{ 
                  game.nextTurn();  // if not chained end the ai player's turn
                  startTurn();
               }
            }
            else{ // PLAYER PASS TURN
               game.nextTurn();
               startTurn();
            }
         
         }
         // USER SELECTS SWAP MOVE
         else if (action.equals(GamePanel.SWAP_TEXT)){
            if (!boardPanel.isSpaceSelected()){ // should never see so display error messade if we do
               System.out.println("ERROR! Space not selected.");
            }
            else{
               game.getRules().move(boardPanel.getSelectedPawn(),
                                    boardPanel.getSelectedSpace(),
                                    Ruleset.ELEVEN_SWAP); // use swap move
               boardPanel.deselectPawn(); // done with pawn...
               boardPanel.deselectSpace(); // ...and Space
               game.nextTurn();  // end the player's turn
               startTurn();
            } 
         }
         // USER SELECTS BUMP MOVE
         else if (action.equals(GamePanel.BUMP_TEXT)){
            if (!boardPanel.isSpaceSelected()){ // should never see so display error messade if we do
               System.out.println("ERROR! Space not selected.");
            }
            else{
               game.getRules().move(boardPanel.getSelectedPawn(),
                                    boardPanel.getSelectedSpace(),
                                    11); // use regular move
               boardPanel.deselectPawn(); // done with pawn...
               boardPanel.deselectSpace(); // ...and Space
               game.nextTurn();  // but most moves simply end the player's turn
               startTurn();            
            }
         }

         
      }// end of actionperformed(ActionEvent e)
   }// end of class ButtonListener
   
   
//************************************************************************* 
// TEST
//************************************************************************* 
   /**
      Test function which starts a game with hard coded players in an arbitrary
      JFrame.
      DEPRECIATED - no longer main test function, retained just in case
   */
   public static void main(String [ ] args){
      // Hard Coded Players
      ArrayList<Player> p = new ArrayList<Player>();
      p.add(new Player(Color.red, "PLAYER 1", "player1.jpg", AIRules.HUMAN));
      p.add(new Player(Color.blue, "PLAYER 2", "player2.jpg", AIRules.HUMAN));
      // Create the object
      GameController2 g = new GameController2(p);
      // JFrame Boilerplate
      JFrame x = new JFrame();
      x.setTitle("");  // name the window
		x.setSize(600, 600);  // set size
		x.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		x.add(g.getBoardPanel());
		x.setVisible(true);	
   } // end of main


}// end of GameController2